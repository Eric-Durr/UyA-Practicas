{"version":3,"sources":["media/js/cloud.js"],"names":["Zdog","Illustration","Ellipse","Anchor","Group","TAU","Shape","canvas","document","querySelector","width","height","illustration","element","zoom","dragRotate","stroke","dial","addTo","diameter","color","anchorSeconds","path","x","y","closed","translate","anchorMinutes","copyGraph","anchorHours","forEach","hand","indexHand","children","child","indexChild","startingDate","Date","seconds","getSeconds","minutes","getMinutes","hours","getHours","animate","updateRenderGraph","requestAnimationFrame","now","rotate","z"],"mappings":";AAIMA,IAAAA,EAAAA,KADFC,EAAAA,EAAAA,aAAcC,EAAAA,EAAAA,QAASC,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,IAAKC,EAAAA,EAAAA,MAGvCC,EAASC,SAASC,cAAc,UAC9BC,EAAkBH,EAAlBG,MAAOC,EAAWJ,EAAXI,OAGTC,EAAe,IAAIX,EAAa,CACpCY,QAAS,eACTC,KAAK,GAELC,YAAY,IAIRC,EAAS,GAGTC,EAAO,IAAIb,EAAM,CACrBc,MAAON,IAGT,IAAIV,EAAQ,CACVgB,MAAOD,EACPD,OAAAA,EACAG,SAAUT,EAAQM,EAClBI,MAAO,YAGT,IAAIlB,EAAQ,CACVgB,MAAOD,EACPD,OAAAA,EACAI,MAAO,YAIT,IAAMC,EAAgB,IAAIlB,EAAO,CAC/Be,MAAON,IAKT,IAAIN,EAAM,CACRY,MAAOG,EACPL,OAAQA,EAAS,EACjBI,MAAO,oBACPE,KAAM,CACJ,CAAEC,EAAG,EAAGC,GAAIR,GACZ,CAAEO,EAAG,EAAGC,GAAIb,EAAS,IAEvBc,QAAQ,IAKV,IAAIvB,EAAQ,CACVgB,MAAOG,EACPL,OAAAA,EACAI,MAAO,oBACPM,UAAW,CAAEF,GAAIb,EAAS,EAAI,MAKhC,IAAMgB,EAAgBN,EAAcO,YAC9BC,EAAcR,EAAcO,YAIlC,CAACP,EAAeM,EAAeE,GAAaC,QAAQ,SAACC,EAAMC,GACzDD,EAAKE,SAASH,QAAQ,SAACI,EAAOC,GAC5BD,EAAMd,MAAe,OAAA,OAAA,GAAK,IAAMY,EAAc,MAAA,OAAA,GAAK,GAAKG,EAAxD,eAKJ,IAAMC,EAAe,IAAIC,KAErBC,EAAUF,EAAaG,aACvBC,EAAUJ,EAAaK,aACvBC,EAAQN,EAAaO,WAezB,SAASC,IAEPhC,EAAaiC,oBACbC,sBAAsBF,GAGhBG,IAAAA,EAAM,IAAIV,KAEZU,EAAIR,eAAiBD,IACvBA,EAAUS,EAAIR,aACdlB,EAAc2B,OAAOC,EAAI5C,EAAM,GAAKiC,EAEpB,KAAZA,GAA8B,IAAZA,IACpBjB,EAAcY,SAAS,GAAGe,OAAOxB,GAAKnB,EAAM,GAG1C0C,EAAIN,eAAiBD,IACvBA,EAAUO,EAAIN,aACdd,EAAcqB,OAAOC,EAAI5C,EAAM,GAAKmC,EACpB,KAAZA,GAA8B,IAAZA,IACpBb,EAAcM,SAAS,GAAGe,OAAOxB,GAAKnB,EAAM,GAE1C0C,EAAIJ,aAAeH,IACrBE,EAAQK,EAAIJ,WACZd,EAAYmB,OAAOC,EAAI5C,EAAM,GAAKqC,EAC9BA,EAAQ,GAAM,IAChBb,EAAYI,SAAS,GAAGe,OAAOxB,GAAKnB,EAAM,MArCpDgB,EAAcY,SAAS,GAAGe,OAAOxB,EAAIc,EAAU,GAAKjC,EAAM,EAAI,EAC9DsB,EAAcM,SAAS,GAAGe,OAAOxB,EAAIgB,EAAU,GAAKnC,EAAM,EAAI,EAC9DqC,EAAQA,EAAQ,GAAKA,EAAQ,GAAKA,EAClCb,EAAYI,SAAS,GAAGe,OAAOxB,EAAIkB,EAAQ,EAAIrC,EAAM,EAAI,EAGzDgB,EAAc2B,OAAOC,EAAI5C,EAAM,GAAKiC,EACpCX,EAAcqB,OAAOC,EAAI5C,EAAM,GAAKmC,EACpCX,EAAYmB,OAAOC,EAAI5C,EAAM,GAAKqC,EAoClCE","file":"cloud.ae4fbd8f.js","sourceRoot":"..","sourcesContent":["\n  // extract the necessary modules from the Zdog library\nconst {\n    Illustration, Ellipse, Anchor, Group, TAU, Shape,\n  } = Zdog;\n  \n  const canvas = document.querySelector('canvas');\n  const { width, height } = canvas;\n  \n  // create an illustration out of the canvas element\n  const illustration = new Illustration({\n    element: '.zdog-canvas',\n    zoom:0.5,\n    // allow for drag\n    dragRotate: true,\n  });\n  \n  // stroke used for the dial and to compute the stroke of the other shapes\n  const stroke = 20;\n  \n  // group describing the clock's dial\n  const dial = new Group({\n    addTo: illustration,\n  });\n  // outer stroke\n  new Ellipse({\n    addTo: dial,\n    stroke,\n    diameter: width - stroke,\n    color: '#272A5B',\n  });\n  // inner circle\n  new Ellipse({\n    addTo: dial,\n    stroke,\n    color: '#272A5B',\n  });\n  \n  // for each hand include an anchor element, to rotate from the center of the clock\n  const anchorSeconds = new Anchor({\n    addTo: illustration,\n  });\n  \n  // each hand is made of a path and a circle\n  // the path reaches outward before using an arc to wrap around the circle\n  new Shape({\n    addTo: anchorSeconds,\n    stroke: stroke / 2,\n    color: 'hsl(60, 80%, 52%)',\n    path: [\n      { x: 0, y: -stroke },\n      { x: 0, y: -height / 2 },\n    ],\n    closed: false,\n    // rotate: { y: TAU / 2 },\n  });\n  \n  // the circle is positioned at the center of the hypothetical circle made by the path's arcs\n  new Ellipse({\n    addTo: anchorSeconds,\n    stroke,\n    color: 'hsl(60, 95%, 52%)',\n    translate: { y: -height / 5 - 35 },\n  });\n  \n  \n  // copy the anchor for the other two hands\n  const anchorMinutes = anchorSeconds.copyGraph();\n  const anchorHours = anchorSeconds.copyGraph();\n  \n  // loop through the children of every anchor to update the hue\n  // starting at 60 and rotating around the color wheel\n  [anchorSeconds, anchorMinutes, anchorHours].forEach((hand, indexHand) => {\n    hand.children.forEach((child, indexChild) => {\n      child.color = `hsl(${60 + 120 * indexHand}, ${80 + 15 * indexChild}%, 52%)`;\n    });\n  });\n  \n  // retrieve the current number of seconds, minutes and hours\n  const startingDate = new Date();\n  \n  let seconds = startingDate.getSeconds();\n  let minutes = startingDate.getMinutes();\n  let hours = startingDate.getHours();\n  \n  // for each anchor rotate the first child according to the time's value\n  // the idea is to have the arc wrap always below the circle\n  anchorSeconds.children[0].rotate.y = seconds > 30 ? TAU / 2 : 0;\n  anchorMinutes.children[0].rotate.y = minutes > 30 ? TAU / 2 : 0;\n  hours = hours > 12 ? hours - 12 : hours;\n  anchorHours.children[0].rotate.y = hours > 6 ? TAU / 2 : 0;\n  \n  // rotate the anchors according to the initial value\n  anchorSeconds.rotate.z = TAU / 60 * seconds;\n  anchorMinutes.rotate.z = TAU / 60 * minutes;\n  anchorHours.rotate.z = TAU / 12 * hours;\n  \n  // function called through the request animation function\n  function animate() {\n    // update the graph\n    illustration.updateRenderGraph();\n    requestAnimationFrame(animate);\n  \n    // retrieve an instance of the date object\n    const now = new Date();\n    // if the number of seconds changes from the previous observation, update teh matching anchor\n    if (now.getSeconds() !== seconds) {\n      seconds = now.getSeconds();\n      anchorSeconds.rotate.z = TAU / 60 * seconds;\n      // if the hand passes past the pre-established threshold, rotate the path to wrap it around the circle in the opposite direction\n      if (seconds === 30 || seconds === 0) {\n        anchorSeconds.children[0].rotate.y += TAU / 2;\n      }\n      // repeat for the number of minutes and hours\n      if (now.getMinutes() !== minutes) {\n        minutes = now.getMinutes();\n        anchorMinutes.rotate.z = TAU / 60 * minutes;\n        if (minutes === 30 || minutes === 0) {\n          anchorMinutes.children[0].rotate.y += TAU / 2;\n        }\n        if (now.getHours() !== minutes) {\n          hours = now.getHours();\n          anchorHours.rotate.z = TAU / 24 * hours;\n          if (hours % 6 === 0) {\n            anchorHours.children[0].rotate.y += TAU / 2;\n          }\n        }\n      }\n    }\n  }\n  \n  animate();\n  "]}